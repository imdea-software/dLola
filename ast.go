package dLola

import (
	//	"errors"
	"fmt"
	//	"log"
	//	"strconv"
	//	"strings"
)

type StreamType int

const (
	NumT StreamType = iota
	BoolT
	StringT
	Unknown  // we use this in the parser for unknow type values (offset expressions) that will be resolved later
	LastType = StringT
)

type StreamName string

func (s StreamName) Sprint() string {
	return string(s)
}

func (t StreamType) Sprint() string {

	type_names := []string{"num", "bool", "string"}

	// str string
	// switch t {
	// case Int:
	// 	str = "int"
	// case Bool:
	// 	str = "bool"
	// case String:
	// 	str = "string"
	// }
	// return str

	if t >= LastType {
		return ""
	}
	return fmt.Sprintf("%s", type_names[t])
}

/*func (t StreamType) Eq(o StreamType) bool {

}*/

type Position struct {
	Line, Col, Offset int
}

type ConstDecl struct { // const int one_sec := 1s
	Name StreamName
	Type StreamType
	Val  Expr
	Pos  Position
}
type InputDecl struct { // input int bar
	Name StreamName
	Type StreamType
	Pos  Position
}
type OutputDecl struct { // output int foo /* this is just a decl, later a tick and a def will be given */
	Name StreamName
	Type StreamType
	Pos  Position
}

/*lm: not needed type TicksDecl struct {
	Name  StreamName
	Ticks TickingExpr
}*/

type OutputDefinition struct {
	Name StreamName
	Type StreamType
	Expr Expr // chango to ValueExpr?
	Pos  Position
}

func NewPosition(p interface{}) Position {
	po := p.(position) //this type is defined in parser.go as part of the PIGEON library
	return Position{po.line, po.col, po.offset}
}

func NewConstDecl(n, t, e, p interface{}) ConstDecl {
	name := getStreamName(n)
	return ConstDecl{name, t.(StreamType), e.(Expr), NewPosition(p)}
}
func NewInputDecl(n, t, p interface{}) InputDecl {
	name := getStreamName(n)
	return InputDecl{name, t.(StreamType), NewPosition(p)}
}
func NewOutputDecl(n, t, p interface{}) OutputDecl {
	name := getStreamName(n)
	return OutputDecl{name, t.(StreamType), NewPosition(p)}
}

/*: not needed func NewTicksDecl(n, t interface{}) TicksDecl {
	name := getStreamName(n)
	expr := t.(TickingExpr)
	return TicksDecl{name, expr}
}*/

func NewOutputDefinition(n, t, e, p interface{}) OutputDefinition {
	name := getStreamName(n)
	expr := e.(Expr)
	return OutputDefinition{name, t.(StreamType), expr, NewPosition(p)}
}

func getStreamName(a interface{}) StreamName {
	return StreamName(a.(Identifier).Val)
}

/*Calls to the parser generated by PIGEON and returns a list of all the trees matched (each sentence will have a tree)
after that, ProcessDeclarations is called which returns a Spec */
func GetAst(filename, prefix string) (*Spec, error) {
	ast, err := ParseFile(filename)
	if err != nil {
		fmt.Printf(prefix+"There was an error: %s\n", err)
		return ProcessDeclarations([]interface{}{})
	}
	last := ast.([]interface{})
	/*TODO: perform castings before returning -> it wont work since the output type will still be []interface{}, so direct call to methods won't work*/
	return ProcessDeclarations(last)
}

/*Gets the output of GetAst and prints it*/
/*func PrintAst(ast []interface{}, prefix string) {
	for _, val := range ast {
		switch v := val.(type) {
		case ConstDecl:
			fmt.Printf(prefix+"%s\n", v.Sprint())
		case InputDecl:
			fmt.Printf(prefix+"%s\n", v.Sprint())
		case OutputDecl:
			fmt.Printf(prefix+"%s\n", v.Sprint())
		case OutputDefinition:
			fmt.Printf(prefix+"%s\n", v.Sprint())

		}
	}
}
*/

//
// DEPRECATED (MOVED ELSEWHERE)
//
// type Event struct {
// 	Payload string // changeme
// //	Stamp []Tag
// }
// //
// // eval(Event e) bool
// //
// func (p AndPredicate) Eval(e Event) bool {
// 	return p.Left.Eval(e) && p.Right.Eval(e)
// }
// func (p OrPredicate) Eval(e Event) bool {
// 	return p.Left.Eval(e) || p.Right.Eval(e)
// }
// func (p NotPredicate) Eval(e Event) bool {
// 	return !p.Inner.Eval(e)
// }
// func (p TruePredicate) Eval(e Event) bool {
// 	return true
// }
// func (p FalsePredicate) Eval(e Event) bool {
// 	return false
// }

//type Monitor Filters

type Tag struct {
	//	Tag dt.Channel
	Tag string
}

type Identifier struct {
	Val string
}

type PathName struct {
	Val string
}
type QuotedString struct {
	Val string
}

type Alphanum struct {
	Val string
}

type Keyword struct {
	Val string
}

func NewIdentifier(s string) Identifier {
	return Identifier{s}
}
func NewPathName(s string) PathName {
	return PathName{s}
}
func NewQuotedString(s string) QuotedString {
	return QuotedString{s}
}

func ToSlice(v interface{}) []interface{} {
	if v == nil {
		return nil
	}
	return v.([]interface{})
}
