{
package dLola

import(
	"strconv"
)

}

Input  <- _? d:(Declaration*)  EOF {
       // returns a []interface{} where all elements are
       //    Const, Input, Output, Ticks or Definitions
       return d,nil
       }

Declaration <- com:Comment {return com, nil } 
 	    / i:InputStreamDecl   { return i,nil }
	    / k:Const              { return k,nil }
//	    / o:OutputStreamDecl       { return o,nil }
	    / d:OutputDefinition   { return d,nil }

Const <- CONST t:Type n:Name ASSIGN e:Expr { 
      // if !checkGround(e) { return nil,err }
      fmt.Sprintf("")
      return NewConstDecl(n,t,e,c.pos),nil //c.pos is a struct defined in parser.go (once generated) containing line, col and offset
}

InputStreamDecl <- INPUT t:Type n:Name {
    return NewInputDecl(n,t, c.pos),nil
}

OutputDefinition <- d:DefOut t:Type n:Name _? ASSIGN _? e:Block {
    return NewOutputDefinition(n,t,e, c.pos),nil
}

DefOut <- DEFINE / OUTPUT{
       return c.text,nil
}

/*OutputStreamDecl <- OUTPUT t:Type n:Name {
    return NewOutputDecl(n,t),nil	  
}*/

Block <- LET n:Name ASSIGN e:Expr IN b:Block _? { return NewLetExpr(n,e,b),nil }
       / e:Expr                                  { return e,nil }

Expr <- IF p:BooleanExpr THEN a:Expr ELSE b:Expr { return NewIfThenElseExpr(p,a,b),nil }
     / b:BooleanExpr { return b,nil }
     / n:NumExpr{ return n, nil }
     / s:StrExpr{return s, nil}
     
// BooleanExpressions
// Big OR of ANDS -> ands will be evaluated first and then ors
BooleanExpr <- a:Ands    b:(OrExpr*) {
	       preds := ToSlice(b)
	       if len(preds)==0 {
	       	  //fmt.Printf("boolean expr without or\n")
	       	  v, err := getBoolExpr(a)
		  //fmt.Printf("Error %s", err)
		  if err == nil{
		     //fmt.Printf("boolean NO error")
	       	     return BooleanExprToExpr(v),nil //old: a,nil lm:BooleanExprToExpr(a), nil
		  } else {
		  //fmt.Printf("boolean error")
		    return nil, errors.New("BooleanExpr: Ands expression is not boolean")
		  }
	       }
	       //fmt.Printf("boolean expr with ors")
	       return BooleanExprToExpr(NewOrPredicate(a,b)),nil
	    }

OrExpr      <- OR _? p:Ands            { return p,nil }

Ands        <- a:NegExpr b:(AndExpr*)     {
	       preds := ToSlice(b)
	       if len(preds)==0 { return a,nil }
	       return BooleanExprToExpr(NewAndPredicate(a,b)),nil
	    }
	    
AndExpr     <- AND _? p:NegExpr { return p,nil }

NegExpr     <- NOT _? p:NegExpr {
	    v, ok := p.(BoolExpr)
	    var pred NotPredicate
	    if ok{
	       pred = NewNotPredicate(v.BExpr) 
	    } else{
	       pred = NewNotPredicate(p)
	    }
	    return NewBoolExpr(pred),nil
	    }
	 /  p:Primary { return p,nil }
	 
Primary   <- '(' _? p:BooleanExpr _? ')' _?  { return p,nil }
	   / n:NumComparison _?              { return BooleanExprToExpr(NewNumComparisonPredicate(n)),nil }
	   / s:StrComparison _? {return BooleanExprToExpr(NewStrComparisonPredicate(s)),nil}
	   / a:AtomicBool _? {return a, nil}  // old:return a,nil testing:getBoolExpr(a)



NumComparison <- a:NumExpr _? "<"  _? b:NumExpr { na,_:= getNumExpr(a)
	      	 	   	   	     nb,_:= getNumExpr(b)
	      	 	   	   	     return NewNumLess(na,nb),nil }
              /  a:NumExpr _? "<=" _? b:NumExpr { na,_:= getNumExpr(a)
	      	 	   	   	     nb,_:= getNumExpr(b)
					     return NewNumLessEq(na,nb),nil }
              /  a:NumExpr _? "="  _? b:NumExpr { na,_:= getNumExpr(a)
	      	 	   	   	     nb,_:= getNumExpr(b)
					     return NewNumEq(na,nb),nil }
              /  a:NumExpr _? ">"  _? b:NumExpr { na,_:= getNumExpr(a)
	      	 	   	   	     nb,_:= getNumExpr(b)
					     return NewNumGreater(na,nb),nil }
              /  a:NumExpr _? ">=" _? b:NumExpr { na,_:= getNumExpr(a)
	      	 	   	   	     nb,_:= getNumExpr(b)
					     return NewNumGreaterEq(na,nb),nil }
	      /	 a:NumExpr _? "!=" _? b:NumExpr { na,_:= getNumExpr(a)
	      	 	   	   	     nb,_:= getNumExpr(b)
					     return NewNumNotEq(na,nb),nil }

StrComparison <- a:StrExpr _? "sEq"  _? b:StrExpr { na,_:= getStrExpr(a)
	      	 	   	   	     nb,_:= getStrExpr(b)
	      	 	   	   	     return NewStrEqExpr(na,nb),nil }


/*Numeric expressions*/
NumExpr  <- a:Mults b:(Plus*) {
	    //fmt.Printf("aa")
	     exprs := ToSlice(b) // common.ToSlice(b)
	     if len(exprs)==0 {
	     //fmt.Printf("NumExpr of an Atom: %s\n", a)
	     	v,err := getNumExpr(a)
		if err == nil {
	           return NumExprToExpr(v),nil //old: NumExprToExpr(a.(NumExpr)),nil lm: NumExprToExpr(getNumExpr(a))
		} else {
		  return nil, errors.New("NumExpr: Mults expression is not numeric\n")
		}
	     } else {
	       return Flatten(a,b),nil // common.Flatten(a,b)
	     }
          }
	  
Plus    <- '+' _? e:Mults { return NewRightPlusExpr(e),nil  }
         / '-' _? e:Mults { return NewRightMinusExpr(e),nil  }
	 
Mults    <- a:BasicNumExpr b:(MoreMults*) {
	     exprs := ToSlice(b) // common.ToSlice(b)
	     if len(exprs)==0 { return a,nil }
	     return Flatten(a,b),nil // common.Flatten(a,b)
          }
	  
MoreMults <- '*' _? e:BasicNumExpr { v, err := getNumExpr(e)
	     	    		     if err == nil{
	     	    		     	   return NewRightMultExpr(v),nil // common. NewRightMultExpr(e)
					   } else {
					   return nil, errors.New("MoreMults: BasicNumExpr is not numeric")
				     }}
          /  '/' _? e:BasicNumExpr { v, err := getNumExpr(e)
	     	    		     if err == nil{
	     	    		     	return NewRightDivExpr(v),nil // common. NewRightMultExpr(e)
				     } else {
				     	   return nil, errors.New("MoreMults: BasicNumExpr is not numeric")
				     }}
	  
BasicNumExpr <- '(' _? n:NumExpr ')' _?   { return n,nil } //old: n lm: getNumExpr(n)
           / a:AtomicNum { return a,nil } //return a, nil lm:added getNumExpr(a)


StrExpr <- a:BasicStrExpr b:(MoreStr*){
	     exprs := ToSlice(b) // common.ToSlice(b)
	     if len(exprs)==0 {
	     	v,err := getStrExpr(a)
		if err == nil {
	           return StrExprToExpr(v),nil //old: NumExprToExpr(a.(NumExpr)),nil lm: NumExprToExpr(getNumExpr(a))
		} else {
		  return nil, errors.New("StrExpr: Str expression is not string\n")
		}
	     } else {
	       return FlattenStr(a,b),nil // common.Flatten(a,b)
	     }
          }
    
MoreStr <- STRCONCAT _? e:BasicStrExpr { v, err := getStrExpr(e)
	     	    		     if err == nil{
	     	    		     	   return NewRightStrConcatExpr(v),nil 
					   } else {
					   return nil, errors.New("MoreStr: BasicStrExpr is not string")
				     }}

BasicStrExpr <- '(' _? s:StrExpr ')' _?   { return s,nil } 
           / a:AtomicStr { return a,nil } 


/*Atoms used for each theory(type)*/
AtomicBool <- co:ConstBool		    { return co, nil}
	      / e:StreamExpr              { return NewStreamOffsetExpr(e),nil }

AtomicNum <-  e:StreamExpr              { return NewStreamOffsetExpr(e),nil }
       	      / co:ConstNum		    { return co, nil}

AtomicStr <-  e:StreamExpr              { return NewStreamOffsetExpr(e),nil }
       	      / co:ConstStr		    { return co, nil}

/*Streams are generic*/
StreamExpr <- n:Name "["  _? t:OffsetExpr _? "|" _? co:Constant _? "]" _? { return NewStreamFetchExpr(n,t,co, c.pos),nil }
	      / n:Name { return NewStreamFetchExpr(n,NewIntLiteralExpr(0, c.pos), nil, c.pos), nil } 

OffsetExpr <- n:NumLiteral {return n, nil}

/*Every constant of every type, only accesible from StreamExpr as a default value!!!*/
Constant <- b:ConstBool {return b,nil}
	    / n:ConstNum {return n,nil}
	    / s:ConstStr {return s,nil}
//	/ k:ConstExpr               { return NewConstExpr(k),nil } // constant uses are treated syntactically as stream names

/*Constants for each type*/
ConstBool <- TRUE _?                 { return NewTruePredicate(c.pos),nil } //old:TrueExpr{c.pos},nil lm:
           / FALSE _?                  { return NewFalsePredicate(c.pos),nil }
	   
ConstNum <- l:NumLiteral _?           { return l,nil } //old:NewNumericExpr(l),nil this returns an NumericExpr which is an Expr, but in the general case the Numliteral will be in a NumExpr

ConstStr <- l:QuotedString _?          { return l,nil } 

ConstExpr <- n:Name { return n,nil } 


NumLiteral <- p:(('-')?[0-9]+('.'[0-9]+)?) {
	      if strings.Contains(string(c.text), ".") {
//	      	 x,err := strconv.ParseFloat(p.(string),32)
		 x,err := strconv.ParseFloat(string(c.text),32)
	      	 return NewFloatLiteralExpr(x, c.pos), err
	      } else {
	      	 x,err := strconv.ParseInt(string(c.text),10,32)
	      	 return NewIntLiteralExpr(int(x), c.pos), err
	      }
	      
	   }

Type <- NUM     { return NumT, nil  }
     /  BOOL    { return BoolT, nil }
     /  STRING  { return StringT,nil}

Name <- n:Identifier _? { return n.(Identifier),nil }

QuotedString <- ('"'(([^'"''\\']*('\\'.[^'"''\\']*)*))'"')  {
	        str := string(c.text)
	     	inner := str[1:len(str)-1]
     	        return NewStringLiteralExpr(inner, c.pos),nil //old:NewQuotedString lm:
        }
	
JSONPath <- ([a-zA-Z0-9]+('.'[a-zA-Z0-9]+)*) {
	 return NewPathName(string(c.text)),nil
	 }	 

Identifier <- ([a-zA-Z]['_''-''@'a-zA-Z0-9]*) {
	   // IMPORTANT: cannot have '.' to distinguish from "e.path" "e.strcmp"
	   return Identifier{string(c.text)}, nil
	   }

String   <- ([a-zA-Z0-9'#''_''-''@']+) 

Alphanum <- ([a-zA-Z0-9]+) { return Alphanum{string(c.text)},nil }

Tag  "tag"      <- ( '#'[a-zA-Z](['_''-''.'a-zA-Z0-9])* )    { return Tag{string(c.text)},nil }

_ "whitespace" <- [ \t\n\r]+

//EOL     <- _? Comment? ("\r\n" / "\n\r" / "\r" / "\n" / EOF)
EOL     <- ("\r\n" / "\n\r" / "\r" / "\n")

Comment <- // "//" [^\r\n]* [\r\n] {return "",nil }
	  _? "/*" [^*/]* "*/" _?  { return "", nil}
EOF     <- !.

// 
// Striver Keywords
//
//DOT_TICKS <- ".ticks" _?
//DELAY  <- "delay" _? 
OUTPUT <- "output" _?
INPUT  <- "input" _?
//TICKS  <- "ticks" _?
CONST  <- "const" _?
DEFINE <- "define" _?
LET    <- "let" _?
IN     <- "in" _?
//UNION  <- "U" _? 
CONST <- "const" _
//OUTSIDE <- "outside" _?
//NOTICK  <- "notick" _?
//PREV   <- "<<" _?
//PREVEQ <- "<~" _?
//SUCC   <- ">>" _?
//SUCCEQ <- "~>" _?
INT    <- "int" _
NUM    <- "num" _
BOOL   <- "bool" _
STRING <- "string" _
IF   <- "if" _
THEN <- "then" _
ELSE <- "else" _
ASSIGN <- "=" _?
TRUE <- "true" _ / "true" EOF
FALSE <- "false" _ / "false" EOF
AND <- "and" _? //"/\\" _?
OR <- "or" _? //"\\/" _?
NOT <- "not" _? //"~" _?
STRCONCAT <- "sConcat" _? 

/*Function <- n:Name '(' a:Args ')' { //TODO: return proper data
	    return n, nil
}

Args <- e:Expr "," a:Args {
     	      v := a.([]interface{})
	     return append(v,e),nil
}
     / e:Expr {return []interface{}{e}, nil}

*/