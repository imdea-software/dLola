{
package dLola

import(
	"strconv"
)

}

Input  <- _? d:(Declaration*)  EOF {
       // returns a []interface{} where all elements are
       //    Const, Input, Output, Ticks or Definitions
       return d,nil
       }

Declaration <- i:InputStreamDecl   { return i,nil }
	    / k:Const              { return k,nil }
//	    / o:OutputStreamDecl       { return o,nil }
	    / d:OutputDefinition   { return d,nil }

Const <- CONST t:Type n:Name ASSIGN e:Expr { 
      // if !checkGround(e) { return nil,err }
      fmt.Sprintf("")
      return NewConstDecl(n,t,e),nil 
}

InputStreamDecl <- INPUT t:Type n:Name {
    return NewInputDecl(n,t),nil
}

OutputDefinition <- d:DefOut t:Type n:Name _? ASSIGN e:Block {
		 if d == "output"{
		    NewOutputDecl(n,t) //store it
		 }
    return NewOutputDefinition(n,t,e),nil	 		 
}

DefOut <- DEFINE / OUTPUT{
       return c.text,nil
}

/*OutputStreamDecl <- OUTPUT t:Type n:Name {
    return NewOutputDecl(n,t),nil	  
}*/

Block <- LET n:Name ASSIGN e:Expr IN b:Block _? { return NewLetExpr(n,e,b),nil }
      / e:Expr                                  { return e,nil }

Expr <- IF p:BooleanExpr THEN a:Expr ELSE b:Expr { return NewIfThenElseExpr(p,a,b),nil }
     / b:BooleanExpr { return b,nil }
     / n:NumExpr{ return n, nil }

// BooleanExpressions
// Big OR of ANDS -> ands will be evaluated first and then ors
BooleanExpr <- a:Ands    b:(OrExpr*)      {
	       preds := ToSlice(b)
	       if len(preds)==0 { return a,nil }
	       return BooleanExprToExpr(NewOrPredicate(a,b)),nil
	    }

OrExpr      <- OR p:Ands            { return p,nil }

Ands        <- a:NegExpr b:(AndExpr*)     {
	       preds := ToSlice(b)
	       if len(preds)==0 { return a,nil }
	       return BooleanExprToExpr(NewAndPredicate(a,b)),nil
	    }
	    
AndExpr     <- AND p:NegExpr         { return p,nil }

NegExpr     <- NOT p:NegExpr {
	    v, ok := p.(BoolExpr)
	    var pred NotPredicate
	    if ok{
	       pred = NewNotPredicate(v.BExpr) 
	    } else{
	       pred = NewNotPredicate(p)
	    }
	    return NewBoolExpr(pred),nil
	    }
	 /  p:Primary                     { return p,nil }
	 
Primary   <- '(' _? p:BooleanExpr ')' _?  { return p,nil }
	     / a:Atomic {return a, nil}
         / n:NumComparison              { return NewNumComparisonPredicate(n),nil }

NumComparison <- a:NumExpr "<"  _? b:NumExpr { return NewNumLess(a,b),nil }
              /  a:NumExpr "<=" _? b:NumExpr { return NewNumLessEq(a,b),nil }
              /  a:NumExpr "="  _? b:NumExpr { return NewNumEq(a,b),nil }
              /  a:NumExpr ">"  _? b:NumExpr { return NewNumGreater(a,b),nil }
              /  a:NumExpr ">=" _? b:NumExpr { return NewNumGreaterEq(a,b),nil }
	      /	 a:NumExpr "!=" _? b:NumExpr { return NewNumNotEq(a,b),nil }


/*Numeric expressions*/
NumExpr  <- a:Mults b:(Plus*) {
	     exprs := common.ToSlice(b)
	     if len(exprs)==0 {
	        return a,nil
	     } else {
	       return common.Flatten(a,b),nil
	     }
          }
	  
Plus    <- '+' _? e:Mults { return NewRightPlusExpr(e),nil  }
         / '-' _? e:Mults { return NewRightMinusExpr(e),nil  }
	 
Mults    <- a:BasicNumExpr b:(MoreMults*) {
	     exprs := common.ToSlice(b)
	     if len(exprs)==0 { return a,nil }
	     return common.Flatten(a,b),nil
          }
	  
MoreMults <- '*' _? e:BasicNumExpr { return common.NewRightMultExpr(e),nil }
          /  '/' _? e:BasicNumExpr { return common.NewRightDivExpr(e),nil }
	  
BasicNumExpr <- '(' _? n:NumExpr ')' _?   { return n,nil }
           / a:Atomic { return a,nil }

Atomic <- e:StreamExpr              { return NewStreamOffsetExpr(e),nil }
       	  / co:Constant		    { return co, nil}
        
StreamExpr <- n:Name "["  _? t:OffsetExpr "|" Constant "]" _? { return NewStreamFetchExpr(n,t),nil }

OffsetExpr <- "+" n:NumLiteral {return n, nil}
	      / "-" n:NumLiteral {return n, nil}

NumLiteral <- p:([0-9]+('.'[0-9]+)?) {
//	      x,err := strconv.ParseFloat(p.(string),32)
	      x,err := strconv.ParseFloat(string(c.text),32)
	      return NewFloatLiteralExpr(x), err
	   }

Constant <- TRUE _?                 { return TrueExpr,nil }
        / FALSE _?                  { return FalseExpr,nil }
	/ k:ConstExpr               { return NewConstExpr(k),nil }
        / l:NumLiteral _?           { return NewNumericExpr(l),nil }


ConstExpr <- n:Name { return n,nil } 


Type <- NUM     { return NumT, nil  }
     /  BOOL    { return BoolT, nil }
     /  STRING  { return StringT,nil}

Name <- n:Identifier _? { return n.(Identifier),nil }

QuotedString <- ('"'(([^'"''\\']*('\\'.[^'"''\\']*)*))'"')  {
	        str := string(c.text)
	     	inner := str[1:len(str)-1]
     	        return NewQuotedString(inner),nil
        }
	
JSONPath <- ([a-zA-Z0-9]+('.'[a-zA-Z0-9]+)*) {
	 return NewPathName(string(c.text)),nil
	 }	 

Identifier <- ([a-zA-Z]['_''-''@'a-zA-Z0-9]*) {
	   // IMPORTANT: cannot have '.' to distinguish from "e.path" "e.strcmp"
	   return Identifier{string(c.text)}, nil
	   }

String   <- ([a-zA-Z0-9'#''_''-''@']+) 

Alphanum <- ([a-zA-Z0-9]+) { return Alphanum{string(c.text)},nil }

Tag  "tag"      <- ( '#'[a-zA-Z](['_''-''.'a-zA-Z0-9])* )    { return Tag{string(c.text)},nil }

_ "whitespace" <- [ \t\n\r]+

//EOL     <- _? Comment? ("\r\n" / "\n\r" / "\r" / "\n" / EOF)
EOL     <- ("\r\n" / "\n\r" / "\r" / "\n")

Comment <- "//" [^\r\n]*

EOF     <- !.

//
// Striver Keywords
//
//DOT_TICKS <- ".ticks" _?
//DELAY  <- "delay" _? 
OUTPUT <- "output" _?
INPUT  <- "input" _?
//TICKS  <- "ticks" _?
CONST  <- "const" _?
DEFINE <- "define" _?
LET    <- "let" _?
IN     <- "in" _?
//UNION  <- "U" _? 
CONST <- "const" _
//OUTSIDE <- "outside" _?
//NOTICK  <- "notick" _?
//PREV   <- "<<" _?
//PREVEQ <- "<~" _?
//SUCC   <- ">>" _?
//SUCCEQ <- "~>" _?
INT    <- "int" _
NUM    <- "num" _
BOOL   <- "bool" _
STRING <- "string" _
IF   <- "if" _
THEN <- "then" _
ELSE <- "else" _
ASSIGN <- "=" _?
TRUE <- "true" _ / "true" EOF
FALSE <- "false" _ / "false" EOF
AND <- "and" _? //"/\\" _?
OR <- "or" _? //"\\/" _?
NOT <- "not" _? //"~" _?


